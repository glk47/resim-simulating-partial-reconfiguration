# Using ReSim #

This wiki page describes the steps of using the `ReSim` library (Release 2.3b). For an overview of the `ReSim` library, please refer to the [ReSim Overview](ReSim.md) page.




## System Requirements ##

ReSim is implemented using SystemVerilog and OVM library. It has been tested using QuestaSim/ModelSim 6.5g on Windows XP Professional SP2 machine and should work on other platforms. The tool also require Tcl 8.4 (or later) and Python 2.5 (or later).

The `State Migration` example requires EDK and has only been tested on EDK 12.4.


## ReSim Tool Flow Overview ##

The following figure illustrates the development flow of ReSim-based simulation. Files that are created by the designer are marked by a "pen" symbol. ReSim-based simulation can be performed by three steps: preparing the design/testbench, generating artifacts and running simulation.

  * Preparing the design/testbench: Using ReSim-based simulation, the designers need to reserve a few “holes” in the design and the testbench so that the simulation-only artifacts generated by step 2 can be correctly "plugged" into the simulation envoironment.

  * Generating artifacts: The second step is to create a parameter script that describes DPR-related parameters of the system. ReSim then automatically generates the source code for artifacts based on this script. The generated artifacts can be directly used with the ReSim libraries. Alternatively, the designer can edit the generated artifacts for design-/test-specific needs.

  * Running simulation: After generating and modifiying the artifacts, the designers can compile the source code for the design/testbench, the ReSim library and the generated artifacts to run simulation.


![http://resim-simulating-partial-reconfiguration.googlecode.com/files/fig_gs_flow.jpg](http://resim-simulating-partial-reconfiguration.googlecode.com/files/fig_gs_flow.jpg)

## Preparing the Design ##

Assume that a DRS design has the following design hierarchy: static modules are instantiated in a `system_top`. The system also instantiates a user-defined, static reconfiguration controller, which instantiates the configuration port.

```

system_top 
  static_module
  static_module
  ...
  static_reconfiguration_controller 
    cp_wrapper
  rr_isolation_logic
  rr_wrapper

```

ReSim require designers to instantiate a configuration port wrapper (CP wrapper) (e.g., the `cp_wrapper` module) as the configuration port. ReSim automatically generates a simulation version and an implementation version for the CP wrapper.

  * Simulation version: Takes a SimB as inputs and start simulation-only tasks.
  * Implementation version: Instantiate the ICAP primitive (e.g. `ICAP_VIRTEX6`)

For reconfigurable regions, ReSim does not recommend that designers put their logic directly inside the top-level of the reconfigurable region. ReSim requires designers to create a dummy level of hierarchy, an RR wrapper (e.g., the `rr_wrapper` module), as a placeholder of the RMs to be mapped.

```

// NOT RECOMMENDED 
// ====================

reconfigurable_region_top
  ... ---------------------------- User-defined logic of module A

reconfigurable_region_top
  ... ---------------------------- User-defined logic of module B


// RECOMMENDED (For Implementation)
// ====================

rr_wrapper ----------------------- A wrapper to instantiate one RM, i.e., module A
  reconfigurable_module_A_top ---- The actual top-level of module A
    ... -------------------------- User-defined logic of module A
    ...

rr_wrapper
  reconfigurable_module_B_top
    ...
    ...

// RECOMMENDED (For Simulation)
// ====================
rr_wrapper ------------------------ In simulation, both RMs are instantiated
  reconfigurable_module_A_top
  reconfigurable_module_B_top
  ...

```

ReSim automatically generates source code of RR wrappers for simulation and implementation. The designer need to keep the placeholder for the RR and integrate the generated RR wrapper with the rest of the system.

It should be noted that such an RR wrapper SHOULD **NOT** include any glue logic. Logic should be moved into `reconfigurable_module_A_top`.

It should also be noted that the RR wrapper SHOULD **NOT** have parameter/generic list. The parameters of `reconfigurable_module_A_top`
should be assigned with actual values. Since the reconfigurable modules are synthesized separately with the static logic, parameters of the RMs can not be assigned from the `system_top`. All parameters of the RMs are explicitly assigned inside the `rr_wrapper` module.

```

module rr_wrapper (input sig);

  reconfigurable_module_A_top #(parameter_value) rm (
		.sig           ( sig )
	);

endmodule

```

Apart from the design, ReSim-based simulation requires that the simulation testbench instantiate

  * A simulation model for the memory such as DDR, flash. This memory is used as the storage of the simulation-only bitstreams, and should be connected to the system in the same way as the implemented design. During simulation, the simulation-only bitstreams should be loaded to the memory model, and are transferred to the simulated configuration port by the user design.

  * A simulation-only layer wrapper. This wrapper is a ReSim-generated artifact. It does not have any input or output and can be instantiated anywhere in the testbench.

```

testbench_top 
  system_top
  memory_model
  simulation_only_layer_wrapper

```


## Generating Simulation-only Artifacts ##

In order to reuse the ReSim library for various DRS design styles, designers need to parameterize the library with design-specific information. DPR-related parameters include,

  * The interfacing signals crossing the RR boundary, which are used to generate an RR wrapper that can correctly interleave these signals.

  * The topology (i.e., the affiliation of RMs and RRs) of the user design, which are required to assign numerical IDs to each RM and RR and to parameterize SimBs with the RRID/RMID of target modules.

  * The number of simulation-only frames for each RR, which is used to determine the length of the generated SimBs.

  * Derived artifacts associated with each RR, which are used to generate templates for derived classes.

  * The target FPGA family, which is used to generate a correct CP artifact.

ReSim provides a set of Tcl APIs to help designers integrate the simulation-only layer into their design-specific simulation environment. The following figure illustrates an example of a parameter script. By calling APIs in a Tcl script, the user describes the interfacing signals crossing the RR boundary (Line 3-6), the affiliation of RMs and RRs (Line 8-10), the size and the derived artifacts of RRs (Line 8), and the FPGA family used by the design (Line 12). ReSim generates the parameterized artifacts that can then be correctly instantiated in the design hierarchy. The artifacts include:


  * The CP wrapper (e.g., the `cp_wrapper` module)
  * The RR wrapper (e.g., the `rr_wrapper` module)
  * The simulation-only layer wrapper (e.g., the `sim_only_layer` module)
  * Simulation-only Bitstream files: In both binary format and memory format loadable to ModelSim, in the `./artifacts/sbt` directory.
  * Simulation-only logic allocation files: In the `./artifacts/spy` directory.
  * A SystemVerilog Package file
  * A SystemVerilog Interface file
  * A TODO-LIST file: `./artifacts/xxxx_todolist.txt`
  * A Report file: `./artifacts/xxxx_report.txt`
  * Templates for derived classes.

![http://resim-simulating-partial-reconfiguration.googlecode.com/files/fig_gs_cg.jpg](http://resim-simulating-partial-reconfiguration.googlecode.com/files/fig_gs_cg.jpg)

### Modifying the Generated Artifacts (Optional) ###

For ReSim-based RTL simulation, the generated artifacts are ready to be used directly. As an option, the designer can then edit the generated artifacts for design-/test-specific needs. There are two typical usage scenarios that require modifying the generated artifacts for ReSim-based RTL simulation.

#### Scenario 1: Overriding the default class-based artifacts. ####

Step 2 in the figure illustrates changing the default "x" injection to a user-defined error injector that drives random values to the static region. Such extension is implemented by redefining the virtual functions in the derived classes. Using the factory mechanism provided by the OVM library, the default error injector can be easily overridden with the derived `my_ei` class. Furthermore, the Tcl script automatically generates code (see Step 3 in the figure) that performs the factory override operation. Designers can thus focus on defining the virtual functions in their derived classes without bothering about how to integrate the derived classes. Artifacts that can be overriden include:

  * Device-specific reconfiguration interface: Can be derived to model various interfacing protocols of possible configuration ports.
  * Generic SimB parser: Can be derived to parse real bitstreams.
  * Error injector: Can be derived to define design-/test-specific error sources.
  * Scoreboard: Can be derived to define design-/test-specific coverage items.

#### Scenario 2: Mapping RTL signals to simulation-only configuration frames. ####

The parameter script generates simulation-only logic allocation files (`.sll` files). The .sll files are used to map RTL signals of the user design to the `sp_memory`, which implements simulation-only frames that mimic the configuration frames of the FPGA fabric. The generated `.sll` files are empty by default. For DRS designs that saves and restores module state via the configuration port, the designer needs to modify the generated `.sll` files and explicitly specify the names of RTL signals and the simulation-only frame addresses the signals are mapped to.

## Running Simulation ##

Since the user design/testbench has kept placeholders for ReSim-generated artifacts, the generated/modified artifacts are ready to be integrated to the simulation environment. As described early in this page, the designer needs to

  * Instantiate the generated CP wrapper as part of the reconfiguration controller.
  * Instantiate the generated RR wrapper as part of the top-level user design.
  * Instantiate the simulation-only layer wrapper in the testbench.

The designer then compiles all design source and starts simulation. The simulation commands vary from design to design, and the designer can refer to the TODO-LIST file generated by ReSim for more detailed information about the simulation commands. In general, it involves the following few steps


  * Compile the ReSim library and the generated artifacts

```

# Compile ReSim library 
ModelSim> vlog ... $RSV_HOME/src/rsv_ifs.sv 
ModelSim> vlog ... $RSV_HOME/src/rsv_solyr_pkg.svp 

# Compile ReSim-generated artifacts 
ModelSim> vlog ... ./artifacts/usr_ifs.sv 
ModelSim> vlog ... ./artifacts/usr_solyr_pkg.svp
ModelSim> vlog ... ./artifacts/rr_wrapper.sv 
ModelSim> vlog ... ./artifacts/cp_wrapper.sv 
ModelSim> vlog ... ./artifacts/sim_only_solyr.sv

```


  * Run simulation

```

# Load simulation
ModelSim> vsim -L mtiReSim -permit_unmatched_virtual_intf ...

```

  * Load the generated SimBs into the memory of the simulation environment.

```

# Load SimBs into the bitstream storage memory
ModelSim> mem load -infile ./artifacts/sbt/xxx_bank0.txt ...

```



  * Visualize transactions (Optional)

```

# Visualize transactions after the simulation starts 
ModelSim> add wave sim:/solyr/rr0/rec/usr_trans
ModelSim> add wave sim:/solyr/rr0/rec/sbt_trans

```
